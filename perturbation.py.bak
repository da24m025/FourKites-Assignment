"""Perturbation analysis: move along Hessian top eigenvector and measure loss.

This shows how sensitive the loss is along the direction of maximum curvature.
"""
import argparse
import yaml
import torch
from src.models.small_cnn import SmallCNN
from src.utils.exp import get_dataloaders, load_checkpoint
from src.probes.hessian import power_top_eig


def flatten_params(params):
    """Flatten parameters."""
    return torch.cat([p.detach().view(-1) for p in params])


def unflatten_like(flat, params_template):
    """Unflatten vector to parameter structure."""
    out = []
    idx = 0
    for p in params_template:
        n = p.numel()
        out.append(flat[idx:idx+n].view_as(p))
        idx += n
    return out


def set_model_params(model, param_list):
    """Set model parameters."""
    for p, new in zip(model.parameters(), param_list):
        p.data.copy_(new)


if __name__ == '__main__':
    p = argparse.ArgumentParser()
    p.add_argument('--checkpoint', type=str, required=True)
    p.add_argument('--config', type=str, required=True)
    p.add_argument('--eps_scale', type=float, default=1.0)
    p.add_argument('--steps', type=int, default=41)
    args = p.parse_args()
    
    cfg = yaml.safe_load(open(args.config))
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    tr, te = get_dataloaders(cfg)
    
    model = SmallCNN(num_classes=cfg['model'].get('num_classes', 10))
    ckpt = load_checkpoint(args.checkpoint, map_location=device)
    model.load_state_dict(ckpt['model'])
    model.to(device)
    
    loss_fn = torch.nn.CrossEntropyLoss()
    
    # Get top Hessian eigenvector
    eig, vec = power_top_eig(model, loss_fn, te, device, power_iters=30)
    flat_theta = flatten_params(list(model.parameters())).to(device)
    
    # Normalize eigenvector
    vec = vec / (vec.norm() + 1e-12)
    
    # Perturbation along top eigenvector
    eps_list = torch.linspace(-args.eps_scale, args.eps_scale, args.steps)
    losses = []
    
    for eps in eps_list:
        new_flat = flat_theta + eps * vec
        new_params = unflatten_like(new_flat, list(model.parameters()))
        set_model_params(model, new_params)
        
        with torch.no_grad():
            xb, yb = next(iter(te))
            xb, yb = xb.to(device), yb.to(device)
            losses.append(loss_fn(model(xb), yb).item())
    
    print(f"Top Hessian eigenvalue: {eig:.6f}")
    print(f"\nLoss along top eigenvector:")
    print(f"eps\t\tloss")
    for e, l in zip(eps_list[::4], losses[::4]):
        print(f"{e.item():.4f}\t\t{l:.6f}")
    
    # Curvature proxy: (f(eps) - f(0)) / eps^2 ≈ λ/2
    idx_center = len(eps_list) // 2
    center_loss = losses[idx_center]
    eps_step = eps_list[1] - eps_list[0]
    
    if abs(eps_step.item()) > 1e-6:
        curvature_est = (losses[-1] - center_loss) / (eps_list[-1].item() ** 2)
        print(f"\nCurvature estimate (quadratic approx): {curvature_est:.6f}")
